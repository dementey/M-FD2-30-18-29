
"use strict";

var dictDb=["ТАРА","ЛИПА","ТУРА","ЛУЖА","ПАРК","ЛОЖЬ","ЛУПА","ПЛОТ","МУРА","ПАУК","ПАУТ","ПЛУТ","ЛОЖА","СЛОТ","ПАРА"];
console.log(dictDb);

// B4+
// Дан большой массив слов - словарь.
// Написать функцию, получающую два слова, и строящую за несколько шагов 
// из первого слова второе, за каждый шаг меняя не более одной буквы,
// так, чтобы на каждом шаге получалось допустимое слово (слово из словаря).
// Функция должна вернуть самую короткую цепочку шагов в виде строки.
// Например, при работе со следующим словарём:
// ["ТАРА","ЛИПА","ТУРА","ЛУЖА","ПАРК","ЛОЖЬ","ЛУПА","ПЛОТ","МУРА","ПАУК","ПАУТ","ПЛУТ","ЛОЖА","СЛОТ","ПАРА"]
// при вызове со словами "ЛИСА" и "ЛОСЬ", функция должна вернуть строку:
// "ЛИСА-ЛИПА-ЛУПА-ЛУЖА-ЛОЖА-ЛОЖЬ-ЛОСЬ"
// а при вызове со словами "МУХА" и "СЛОН" - строку:
// "МУХА-МУРА-ТУРА-ТАРА-ПАРА-ПАРК-ПАУК-ПАУТ-ПЛУТ-ПЛОТ-СЛОТ-СЛОН"

// Я бы здесь в теорию не лез, но по сути - решение, которое мне кажется подходящим, больше похоже на поиск в глубину.
// Нужно формировать набор "ходов" - слов, которые можно получить из текущего слова; из каждого из этих слов - снова набор "ходов",
// до тех пор пока не наткнёмся на то слово к которому стремимся.
// Но в условиях сильно ограниченного количества "ходов" (т.е. с очень малым словарём) на каждом уровне у вас будет всего-то один-два хода,
// поэтому, технически это поиск в глубину, фактически - простой перебор с рекурсией.